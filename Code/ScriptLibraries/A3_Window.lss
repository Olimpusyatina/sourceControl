'++LotusScript Development Environment:2:5:(Options):0:74
%REM
	Library A3_Window
	Created Mar 24, 2011 by Sergey A. Tyschuk/PROMP/RU
	Description: Comments for Library
%END REM
Option Public
Option Declare
Use "A1_Setup"

'++LotusScript Development Environment:2:5:(Forward):0:1
Declare Public Class Window
Declare Public Class LNProgressBar
Declare Public Class Registry
Declare Public Class PopupMenu
Declare Sub Initialize

'++LotusScript Development Environment:2:5:(Declarations):0:10
Private Const libName = "A3"
'Private s As System
Private e As ErrorH
Private errS As String
Private errJ As String

Const VK_F9 = &H78
Const KEYEVENTF_KEYDOWN = &H0
Const KEYEVENTF_KEYUP = &H2

%REM
	Type Point
	Description: Comments for Type
%END REM
Private Type Point
	x As Long
	y As Long
End Type

%REM
	Type Rect
	Description: Comments for Type
%END REM
Private Type Rect
	x1 As Long
	y1 As Long
	x2 As Long
	y2 As Long
	
'	Left As Long
'	Top As Long
'	Right As Long
'	Bottom As Long
End Type

Type MSG
	hwnd As Long
	message As Long
	wParam As Long
	lParam As Long
	sTime As Long
	pt As Point
End Type

Declare Private Sub NSFNoteHotspots Lib "nnotes.dll" Alias "NSFNoteHotspots" ()

Declare Private Function GetVersion Lib "kernel32.dll" Alias "GetVersion" () As Long
Declare Private Function URLDownloadToFile Lib "urlmon.dll" Alias "URLDownloadToFile" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long
Declare Private Function NEMPutFile Lib "nnotesws.dll" Alias "NEMPutFile" (wHandle As Long, ByVal szFileName As String, ByVal szFilter As String, ByVal szTitle As String ) As Long
Declare Private Function NEMGetFile Lib "nnotesws.dll" Alias "NEMGetFile" ( wHandle As Long, ByVal szFileName As String, ByVal szFilter As String, ByVal szTitle As String ) As Long

Declare Private Function ShellExecute Lib "shell32.dll" Alias "ShellExecute" (ByVal hwnd As Long, ByVal lpszOp As String, ByVal lpszFile As String, ByVal lpszParams As String, ByVal LpszDir As String, ByVal FsShowCmd As Long) As Long
 
 
Declare Sub keybd_event Lib "user32.dll" (ByVal bVk As Integer, ByVal bScan As Integer, ByVal dwflags As Long, ByVal dwextrainfo As Long)
'keybd_event VK_F9, 0 , KEYEVENTF_KEYDOWN , 0
'keybd_event VK_F9, 0 , KEYEVENTF_KEYUP , 0
 
Declare Private Sub SetWindowPos Lib "user32.dll" Alias "SetWindowPos" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)
Declare Private Function GetActiveWindow Lib "user32.dll" Alias "GetActiveWindow" () As Long
Declare Private Function GetForegroundWindow Lib "user32.dll" Alias "GetForegroundWindow" () As Long
Declare Private Function FindWindow Lib "user32.dll" Alias "FindWindow" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Private Sub SetWindowText Lib "user32.dll" Alias "SetWindowText" (ByVal hWnd As Long, ByVal lpString As String)
Declare Private Function GetWindowText Lib "user32.dll" Alias "GetWindowText" (ByVal hWnd As Long, ByVal lpString As String, ByVal chMax As Long) As Long
Declare Private Function GetTopWindow Lib "user32.dll" Alias "GetTopWindow" () As Long
Declare Private Function GetFocus Lib "user32.dll" Alias "GetFocus" () As Long
Declare Private Function SetFocus Lib "user32.dll" Alias "SetFocus" (ByVal hWnd As Long) As Long
Declare Private Function IsWindowVisible Lib "user32.dll" Alias "IsWindowVisible" (ByVal hWnd As Long) As Long
Declare Private Function GetWindow Lib "user32.dll" Alias "GetWindow" (ByVal hWnd As Long, ByVal wCmd As Long) As Long
Declare Private Function SetForegroundWindow Lib "user32.dll" Alias "SetForegroundWindow" (ByVal hWnd As Long) As Long
Declare Private Function PostMessage Lib "user32.dll" Alias "PostMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Private Function GetMessage Lib "user32.dll" Alias "GetMessageA" (wMsg As MSG, ByVal hwnd As Long, ByVal wParam As Long, ByVal lParam As Long) As Long
Declare Private Function SendMessage Lib "user32.dll" Alias "SendMessage" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lparam As Long) As Long
Declare Private Sub PostQuitMessage Lib "user32.dll" Alias "PostQuitMessage" (ByVal wCmd As Long)
Declare Private Function GetCursorPos Lib "user32.dll" Alias "GetCursorPos" (lpPoint As Point) As Long
Declare Private Function GetWindowRect Lib "user32.dll" Alias "GetWindowRect" (ByVal hwnd As Long, r As Rect) As Long
Declare Private Function GetWindowInfo Lib "user32.dll" Alias "GetWindowInfo" (ByVal hwnd As Long, hinf As Variant) As Long
Declare Private Function GetClientRect Lib "user32.dll" Alias "GetClientRect" (ByVal hwnd As Long, r As Rect) As Long
Declare Private Function GetTempPath Lib "kernel32.dll" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Declare Private Function SetCursorPos Lib "user32.dll" Alias "SetCursorPos" (lpPoint As Point) As Long
Declare Private Function GetCapture Lib "user32.dll" Alias "GetCapture" () As Long
Declare Private Function ReleaseCapture Lib "user32.dll" Alias "ReleaseCapture" () As Long
Declare Private Function SetCapture Lib "user32.dll" Alias "SetCapture" (ByVal hwnd As Long) As Long
Declare Private Function GetAsyncKeyState Lib "user32.dll" Alias "GetAsyncKeyState" (ByVal vKey As Long) As Long
Declare Private Function WindowFromPoint Lib "user32.dll" Alias "WindowFromPoint" (lpPoint As Point) As Long
Declare Private Function ChildWindowFromPoint Lib "user32.dll" Alias "ChildWindowFromPoint" (ByVal hwndParent As Long, lpPoint As Point) As Long
Declare Private Function GetDesktopWindow Lib "user32.dll" Alias "GetDesktopWindow" () As Long
Declare Private Function GetParent Lib "user32.dll" Alias "GetParentWindow" (ByVal hwnd As Long) As Long
Declare Private Function SetWindowLong Lib "user32" Alias "SetWindowLong" (ByVal hwnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Private Function GetWindowLong Lib "user32" Alias "GetWindowLong" (ByVal hwnd As Long, ByVal nIndex As Long) As Long
Declare Private Function GetDC Lib "user32" Alias "GetDC" (ByVal hwnd As Long) As Long
Declare Private Function GetPixel Lib "gdi32" Alias "GetPixel" (ByVal hDC As Long, lpPoint As Point) As Long
Declare Private Function GetLastError Lib "kernel32" Alias "GetLastError" () As String
Declare Private Function IsZoomed Lib "kernel32" Alias "IsZoomed" (ByVal hwnd As Long) As Long
Declare Private Sub Memcpy Lib "msvcrt" Alias "Memcpy" ( D As Any, ByVal P As Long, ByVal N As Long)
Declare Private Function GetCurrentNotesWindow Lib "nnotesws" Alias "GetCurrentNotesWindow" () As Long
Declare Private Function NEMStopSubprogrammWindow Lib "nnotesws" Alias "NEMStopSubprogrammWindow" () As Long

Declare Private Function RegCloseKey Lib "advapi32.dll" Alias "RegCloseKeyA" (ByVal hKey As Long) As Long
Declare Private Function RegQueryValueEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpData As String, lpcbData As Integer) As Long
Declare Private Function RegSetValueEx Lib "advapi32.dll" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal lpData As String, ByVal cbData As Long) As Long
Declare Private Function RegOpenKey Lib "advapi32.dll" Alias "RegOpenKeyA" (ByVal hKey As Long, ByVal lpSubKey As String, phkResult As Long) As Long
Declare Private Function RegOpenKeyEx Lib "advapi32.dll" Alias "RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkResult As Long) As Long
Declare Private Function RegQueryValueSizeEx Lib "advapi32.dll" Alias "RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As Long, lpType As Long, ByVal lpSize As Long, lpcbData As Integer) As Long
Declare Private Function RegDeleteValue Lib "advapi32.dll" Alias "RegDeleteValueA" (ByVal hKey As Long, ByVal lpValueName As String) As Long

Declare Private Function NEMProgressBegin Lib "nnotesws.dll" Alias "NEMProgressBeginA" ( ByVal wFlags As Integer ) As Long
Declare Private Sub NEMProgressDeltaPos Lib "nnotesws.dll" Alias "NEMProgressDeltaPosA" ( ByVal hwnd As Long, ByVal dwIncrement As Long )
Declare Private Sub NEMProgressEnd Lib "nnotesws.dll" Alias "NEMProgressEndA" ( ByVal hwnd As Long )
Declare Private Sub NEMProgressSetBarPos Lib "nnotesws.dll" Alias "NEMProgressSetBarPosA" ( ByVal hwnd As Long, ByVal dwPos As Long)
Declare Private Sub NEMProgressSetBarRange Lib "nnotesws.dll" Alias "NEMProgressSetBarRangeA" ( ByVal hwnd As Long, ByVal dwMax As Long )
Declare Private Sub NEMProgressSetText Lib "nnotesws.dll" Alias "NEMProgressSetTextA" ( ByVal hwnd As Long, ByVal pcszLine1 As String, ByVal pcszLine2 As String )
Declare Private Function NEMEnableWaitCursor Lib "nnotesws.dll" Alias "NEMEnableWaitCursor" () As Long
Declare Private Function NEMDisableWaitCursor Lib "nnotesws.dll" Alias "NEMDisableWaitCursor" () As Long

Declare Private Function GetSystemMenu Lib "user32.dll" Alias "GetSystemMenu" (ByVal hWnd As Long, ByVal bRevert As Long) As Long
Declare Private Function CreatePopupMenu Lib "user32.dll" Alias "CreatePopupMenu" () As Long
Declare Private Function DestroyMenu Lib "user32.dll" Alias "DestroyMenu" (ByVal hMenu As Long) As Long
Declare Private Function GetMenuItemCount Lib "user32.dll" Alias "GetMenuItemCount" (ByVal hMenu As Long) As Long
Declare Private Function SetMenu Lib "user32.dll" ( ByVal hWnd As Long, ByVal hMenu As Long ) As Long
Declare Private Function GetMenu Lib "user32.dll" Alias "GetMenu" (ByVal hWnd As Long) As Long
Declare Private Function AppendMenu Lib "user32.dll" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Any) As Long
Declare Private Function GetMenuString Lib "user32.dll" Alias "GetMenuStringA" (ByVal hMenu As Long, ByVal wIDItem As Long, ByVal lpString As String, ByVal nMaxCount As Long, ByVal wFlag As Long) As Long
Declare Private Function TrackPopupMenu Lib "user32.dll" Alias "TrackPopupMenu" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal x As Long, ByVal y As Long, ByVal nReserved As Long, ByVal hwnd As Long, lprc As Rect) As Long
Declare Private Function DrawMenuBar Lib "user32.dll" Alias "DrawMenuBar" (ByVal hwnd As Long) As Long
Declare Private Function EnableMenuItem Lib "user32.dll" Alias "EnableMenuItem" (ByVal hMenu As Long, ByVal wIDEnableItem As Long, ByVal wIDEnable As Long) As Long
Declare Private Function CheckMenuItem Lib "user32.dll" Alias "CheckMenuItem" (ByVal hMenu As Long, ByVal wIDCheckItem As Long, ByVal wIDCheck As Long) As String
Declare Private Function DeleteMenu Lib "user32.dll" Alias "DeleteMenu" (ByVal hMenu As Long, ByVal nPos As Long, ByVal wFlags As Long) As Long
Declare Private Function InsertMenu Lib "user32.dll" Alias "InsertMenu" (ByVal hMenu As Long, ByVal nPos As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As Any) As Long
Declare Private Function GetMenuItemID Lib "user32.dll" Alias "GetMenuItemID" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Declare Private Function GetSubMenu Lib "user32.dll" Alias "GetSubMenu" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Declare Private Function HiliteMenuItem Lib "user32.dll" Alias "HiliteMenuItem" (ByVal hWnd As Long, ByVal hMenu As Long, ByVal uItemHilite As Long, ByVal uHilite As Long) As Long
Declare Private Function SetMenuDefaultItem Lib "user32.dll" Alias "SetMenuDefaultItem" (ByVal hMenu As Long, ByVal uItem As Long, ByVal fByPos As Long) As Long
Declare Private Function CheckMenuRadioItem Lib "user32.dll" Alias "CheckMenuRadioItem" (ByVal hMenu As Long, ByVal idFirst As Long, ByVal idLast As Long, ByVal idCheck As Long, ByVal wFlags As Long) As Long
Declare Private Function GetMenuItemRect Lib "user32.dll" Alias "GetMenuItemRect" (ByVal hWnd As Long, ByVal hMenu As Long, ByVal uItem As Long, lprcItem As Rect) As Long

Private Const NPB_TWOLINE = 3
Private Const NPB_ONELINE = 2
Private Const NPB_STATUSBAR = 32

Private Const HKEY_CLASSES_ROOT = &H80000000
Private Const HKEY_CURRENT_USER = &H80000001
Private Const HKEY_LOCAL_MACHINE = &H80000002
Private Const HKEY_USERS = &H80000003
Private Const HKEY_PERFORMANCE_DATA = &H80000004
Private Const HKEY_CURRENT_CONFIG = &H80000005
Private Const HKEY_DYN_DATA = &H80000006

Private Const REG_SZ = 1
Private Const REG_BINARY = 3
Private Const REG_DWORD = 4
Private Const REG_ERROR_SUCCESS = 0&




%REM
	Class win
	Description: Comments for Class
%END REM
Public Class Window
	Private p As Point
	Private r As Rect
	Private bar As LNProgressBar
	Private reg As Registry
	Private tmp As String
	
	%REM
		Function getTempDir
		Description: Comments for Function
	%END REM
	Public Function getTempDir() As String
		On Error GoTo eh
		Dim res As Long
		Dim buf As String
		
		If Me.tmp = "" Then
			buf = Space$(256)
			res = GetTempPath(256, buf)
			getTempDir = Left$(buf, res)
			If FullTrim(getTempDir) <> "" Then Me.tmp = getTempDir
		Else
			getTempDir = Me.tmp
		End If
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> window.getTempDir: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Function
	
	%REM
		Sub setCursor
		Description: Comments for Sub
	%END REM
	Public Sub initializeCursor
		On Error GoTo eh

		Call GetCursorPos(Me.p)
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> window.initializeCursor: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Sub
	
	%REM
		Function getCursorPosition
		Description: Comments for Sub
	%END REM
	Public function getCursorPositionX() As Long
		On Error GoTo eh

		getCursorPositionX = Me.p.x
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> window.getCursorPositionX: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Function
	
	Public Function getCursorPositionY() As Long
		On Error GoTo eh

		getCursorPositionY = Me.p.y
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> window.getCursorPositionY: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Function
	
	%REM
		Sub setCursorPosition
		Description: Comments for Sub
	%END REM
	Public Sub setCursorPosition(xTmp As Long, yTmp As Long)
		Me.p.x = xTmp
		Me.p.y = yTmp
	End Sub
End Class
%REM
	Class LNProgressBar
	Description: Comments for Class
%END REM
'Private Class LNProgressBar
Public Class LNProgressBar
	Private hWnd As Long
	Private pos As Long
	Private rang As Long
	
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Public Sub New(barType As Integer)
		On Error GoTo eh
		Select Case barType
			Case 1:
				Me.hWnd = NEMProgressBegin(NPB_ONELINE)
			Case 2:
				Me.hWnd = NEMProgressBegin(NPB_TWOLINE)
			Case Else:
				Me.hWnd = NEMProgressBegin(NPB_STATUSBAR)
		End Select
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> LNProgressBar.New: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Sub
	
	%REM
		Sub setText
		Description: Comments for Sub
	%END REM
	Public Sub setText(txt1 As String, txt2 As String)
		NEMProgressSetText Me.hWnd, txt1, txt2
	End Sub
	
	%REM
		Property Set Position Range
		Description: Comments for Property Set
	%END REM
	Property Set Position As Long
		If Position > 0 Then
			If Position > Me.rang Then
				Me.pos = Me.rang
			Else
				Me.pos = Position
			End If
		End If
		NEMProgressSetBarPos Me.hWnd, Me.pos
	End Property
	
	Property Set Range As Long
		If Range >= 0 Then
			Me.rang = Range
			NEMProgressSetBarRange Me.hWnd, Me.rang
		End If
	End Property
	
	%REM
		Property Get Position Range
		Description: Comments for Property Get
	%END REM
	Property Get Position As Long
		Position = Me.pos
	End Property
	
	Property Get Range As Long
		Range = Me.rang
	End Property
	
	%REM
		Sub toPosition
		Description: Comments for Sub
	%END REM
	Sub toPosition(dpos As Long)
		Me.pos = Me.pos + dpos
		NEMProgressDeltaPos Me.hWnd, dpos
	End Sub
	
	Public Sub Delete()
		NEMProgressEnd Me.hWnd
	End Sub
End Class
%REM
	Class Registry
	Description: Comments for Class
%END REM
'Private Class Registry
Public Class Registry
	Private h As Long
	Private p As String
	Private vr As Long
	Private tp As Long
	Private nm As String
	Private vl As String
	

	Public Sub New
		Me.h = 0
		Me.p = ""
		Me.vr = 0
		Me.nm = ""
		Me.vl = ""
	End Sub
	
	%REM
		Property Set RegHandle, RegPath, RegType, RegName
		Description: Comments for Property Set
	%END REM
	Property Set RegHandle As Long
		Me.h = RegHandle
	End Property
	
	Property Set RegPath As String
		Me.p = RegPath
	End Property
	
	Property Set RegType As Long
		Me.h = RegType
	End Property
	
	Property Set RegName As String
		Me.p = RegName
	End Property
	
	%REM
		Property Set RegHandle, RegPath, RegType, RegName
		Description: Comments for Property Set
	%END REM
	Property Get RegHandle As Long
		RegHandle = Me.h
	End Property
	
	Property Get RegPath As String
		RegPath = Me.p
	End Property
	
	Property Get RegType As Long
		RegType = Me.h
	End Property
	
	Property Get RegName As String
		RegName = Me.nm
	End Property
	
	%REM
		Sub Open
		Description: Comments Sub Open
	%END REM
	Public Sub Open
		On Error GoTo eh
		dim res As Long
		
		res = RegOpenKey(Me.h, Me.p, Me.vr)
		If res <> REG_ERROR_SUCCESS Then Error res, GetLastError()
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> Registry.Open: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Sub
	
	%REM
		Property Get Value
		Description: Comments for Property Get
	%END REM
	Property Get RegValue As String
		On Error GoTo eh
		Dim res As Long
		Dim bSz As Integer
		Dim sB As String
		Dim pos As Integer
		
		If Me.vl = "" then
			res = RegQueryValueSizeEx(Me.vr, Me.nm, 0&, Me.tp, 0, bSz)
			If res <> REG_ERROR_SUCCESS Then Error res, GetLastError()
			If Me.tp <= 2 Then
				sB = String(bSz, " ")
				res = RegQueryValueEx(Me.vr, Me.nm, 0&, 0&, sB, bSz)
				pos = InStr(sB, Chr$(0))
				If pos > 0 Then
					RegValue = Left$(sB, pos - 1)
					Me.vl = RegValue
				Else
					RegValue = sB
				End If
			End If
		Else
			RegValue = Me.vl
		End If
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> Registry.Get Value: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Property
	
	%REM
		Property Set RegValue
		Description: Comments for Property Set
	%END REM
	Property Set RegValue As String
		On Error GoTo eh
		Dim res As Long
		Dim sz As Long
		
		sz = Len(RegValue) + 1
		res = RegSetValueEx(Me.vr, Me.nm, 0, Me.tp, RegValue, sz)
		If res <> REG_ERROR_SUCCESS Then Error res, GetLastError()
		Me.vl = RegValue
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> Registry.Set RegValue: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Property
	
	%REM
		Function Delete
		Description: Comments for Function
	%END REM
	Public Sub Delete
		On Error GoTo eh
		Dim res As Long
		
		res = RegDeleteValue(Me.vr, Me.nm)
		If res <> REG_ERROR_SUCCESS Then Error res, GetLastError()
		
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> Registry.Delete: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Sub
End Class
%REM
	Class Menu
	Description: Comments for Class
%END REM
'Private Class PopupMenu
Public Class PopupMenu
	Private pMenuArr As collection
	Private sMenuArr As collection
	Private count As Long
	Private hMenu As Long
	Private hWnd As Long
	Private p As Point
	Private r As Rect
	Private anim As Long
	Private selected As Long
	Private menuID As Long
	
	%REM
		Sub New
		Description: Comments for Sub
	%END REM
	Public Sub New
		On Error GoTo eh
		Dim activeHWnd As Long
		
		Call GetCursorPos(Me.p)
		activeHWnd = WindowFromPoint(Me.p)
		Me.r.x1 = Me.p.x
		Me.r.y1 = Me.p.y
		Call GetWindowRect(activeHWnd, Me.r)
		Me.hWnd = GetFocus'GetActiveWindow
		Me.hMenu = CreatePopupMenu
		Me.p.x = -1
		Me.p.y = -1
		If Me.menuID = 0 Then Me.menuID = 217748300
		Me.anim = 0
		Set sMenuArr = New collection
		Set pMenuArr = New collection
'		Call sMenuArr.initialize("")
'		Call pMenuArr.initialize("")
		
		GoTo fn
eh:
		If GetLastError() <> "" Then
			errS = Chr(10) & libName & " --> PopupMenu.New: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.New: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Sub
	
	%REM
		Function getItem
		Description: Comments for Function
	%END REM
	Public Function getItem(pos As Variant) As Variant
		On Error GoTo eh
		
		getItem = ""
		If Me.hMenu = 0 Then GoTo fn
		
		Dim l As Long
		Dim p As Long
		Dim i As Long
		Dim menuS As String*128
		Dim w As String
		
		p = CLng(pos - 1)
		l = GetMenuString(Me.hMenu, p, menuS, 0, 1024) + 1
		Call GetMenuString(Me.hMenu, p, menuS, 0, 1024)
		For i = 1 To l - 1
			w = Mid(menuS, i, 1)
			getItem = getItem + w
		Next
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function appendItem
		Description: Comments for Function
	%END REM
	Public Function appendItem(iName As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		Me.menuID = Me.menuID - 1
		Me.count = Me.count + 1
		Call AppendMenu(Me.hMenu, 0, Me.menuID, CStr(iName))
		Call Me.sMenuArr.appendElement(iName)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.appendItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.appendItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function appendItemArray
		Description: Comments for Function
	%END REM
	Public Function appendItemArray(iNames As Variant)
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		ForAll x In iNames
			Call Me.appendItem(x)
		End ForAll
				
		GoTo fn
eh:
		errS = Chr(10) & libName & " --> PopupMenu.appendItemArray: " & Err & ", line " & Erl & Chr(10) & Error$
		Error Err, errS
fn:
	End Function
	
	%REM
		Function itemCount
		Description: Comments for Function
	%END REM
	Public Function itemCount As Long
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		itemCount = GetMenuItemCount(Me.hMenu)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.itemCount: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.itemCount: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function insertItem
		Description: Comments for Function
	%END REM
	Public Function insertItem(iName As Variant, pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Me.menuID = Me.menuID - 1
		Me.count = Me.count + 1
		Call InsertMenu(Me.hMenu, CLng(pos - 1), 1024, Me.menuID, CStr(iName))
	'	Call Me.sMenuArr.insertElement(Nothing, pos)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.insertItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.insertItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function appendSubMenu
		Description: Comments for Function
	%END REM
	Public Function appendSubMenu(menu As Variant, iName As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Dim h As Long
		h = menu.Handle
		If h = 0 Then GoTo fn
		Call AppendMenu(Me.hMenu, 16, h, CStr(iName))
		Call Me.sMenuArr.appendElement(menu)
		Call menu.AddParentMenu(Me)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.appendSubMenu: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.appendSubMenu: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function insertSubMenu
		Description: Comments for Function
	%END REM
	Public Function insertSubMenu(menu As Variant, iName As Variant, pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Dim h As Long
		h = menu.Handle
		If h = 0 Then GoTo fn
		Call InsertMenu(Me.hMenu, pos - 1, 1040, h, CStr(iName))
'		Call Me.sMenuArr.insertElement(menu, pos)
		Call menu.AddParentMenu(Me)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.insertSubMenu: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.insertSubMenu: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function appendSeparator
		Description: Comments for Function
	%END REM
	Public Function appendSeparator As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		Call AppendMenu(Me.hMenu, 2048, 0, "")
		Call Me.sMenuArr.appendElement(Nothing)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.appendSeparator: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.appendSeparator: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function insertSeparator
		Description: Comments for Function
	%END REM
	Public Function insertSeparator(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call InsertMenu(Me.hMenu, pos - 1, 3072, 0, "")
'		Call Me.sMenuArr.insertElement(Nothing, pos)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.insertSeparator: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.insertSeparator: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function deleteItem
		Description: Comments for Function
	%END REM
	Public Function deleteItem(pos As Long) As Variant
		On Error GoTo eh
		Dim menu As Variant
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call DeleteMenu(Me.hMenu, pos - 1, 1024)
		If Not Me.sMenuArr.getElement(pos) Is Nothing Then
			Set menu = Me.sMenuArr.getElement(pos)
			Call menu.removeParentMenu(Me)
		End If
		
'		Call Me.sMenuArr.removeElement(pos)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.deleteItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.deleteItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function appendBreak
		Description: Comments for Function
	%END REM
	Public Function appendBreak(iName As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		Me.menuID = Me.menuID - 1
		Call AppendMenu(Me.hMenu, 64, Me.menuID, CStr(iName))
		Call Me.sMenuArr.appendElement(Nothing)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.appendBreak: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.appendBreak: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function insertBreak
		Description: Comments for Function
	%END REM
	Public Function insertBreak(iName As Variant, pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Me.menuID = Me.menuID - 1
		Call InsertMenu(Me.hMenu, CLng(pos - 1), 1088, Me.menuID, CStr(iName))
'		Call Me.sMenuArr.insertElement(Nothing, pos)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.insertBreak: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.insertBreak: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function AppendBarBreak
		Description: Comments for Function
	%END REM
	Public Function appendBarBreak(iName As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		Me.menuID = Me.menuID - 1
		Call AppendMenu(Me.hMenu, 32, Me.menuID, CStr(iName))
		Call Me.sMenuArr.appendElement(Nothing)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.appendBarBreak: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.appendBarBreak: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function insertBarBreak
		Description: Comments for Function
	%END REM
	Public Function insertBarBreak(iName As Variant, pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Me.menuID = Me.menuID - 1
		Call InsertMenu(Me.hMenu, CLng(pos - 1), 1056, Me.menuID, CStr(iName))
'		Call Me.sMenuArr.insertElement(Nothing, pos)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.insertBarBreak: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.insertBarBreak: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function enableItem
		Description: Comments for Function
	%END REM
	Public Function enableItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call EnableMenuItem(Me.hMenu, pos - 1, 1024)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.enableItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.enableItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function disableItem
		Description: Comments for Function
	%END REM
	Public Function disableItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call EnableMenuItem(Me.hMenu, pos - 1, 1025)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.disableItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.disableItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function checkItem
		Description: Comments for Function
	%END REM
	Public Function checkItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call CheckMenuItem(Me.hMenu, pos - 1, 1032)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.checkItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.checkItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function uncheckItem
		Description: Comments for Function
	%END REM
	Public Function uncheckItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call CheckMenuItem(Me.hMenu, pos - 1, 1024)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.uncheckItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.uncheckItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function checkRadioItem
		Description: Comments for Function
	%END REM
	Public Function checkRadioItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call CheckMenuRadioItem(Me.hMenu, pos - 1, pos - 1, pos - 1, 1024)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.checkRadioItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.checkRadioItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Property Get Handle
		Description: Comments for Property Get
	%END REM
	Property Get Handle As Long
		Handle = Me.hMenu
	End Property
	
	%REM
		Function show
		Description: Comments for Function
	%END REM
	Public Function show As Variant
		On Error GoTo eh
		
		show = ""
		If Me.hMenu = 0 Then GoTo fn
		If Me.hWnd = 0 Then GoTo fn
		
		Dim menuS As String*128
		Dim l As Long
		Dim t As Long
		Dim i As Long
		Dim w As String
		Dim ret As Long
		Dim msgdata As MSG
		
		
		Call SetForegroundWindow(Me.hWnd)
		If Me.p.x < 0 Or Me.p.y < 0 Then Call GetCursorPos(Me.p)
'		Call NEMDisableWaitCursor
		t = TrackPopupMenu(Me.hMenu, 256 + Me.anim, Me.p.x, Me.p.y, 0, Me.hWnd, Me.r)
'		Call NEMEnableWaitCursor
		Me.selected = t
'		l = GetMenuString(Me.hMenu, t, menuS, 0, 0) + 1
'		Call GetMenuString(Me.hMenu, t, menuS, 1, 0)
'		Call PostMessage(Me.hWnd,0, 0, 0)
'		For i = 1 To l - 1
'			w = Mid(menuS, i, 1)
'			show = show + w
'		Next
		ret = GetMessage(msgdata, Me.hWnd, 0, 0)
		'ret = GetMessage(Me.hWnd, 0, 0, 0)
		
		
		
		MsgBox "" & msgdata.message & "**"& msgdata.wParam & "---" & show
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.show: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.show: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function showAsAction
		Description: Comments for Function
	%END REM
	Public Function showAsAction As String
		On Error GoTo eh
		
		showAsAction = ""
		If Me.hMenu = 0 Then GoTo fn
		If Me.hWnd = 0 Then GoTo fn
		
		Dim menuS As String*128
		Dim l As Long
		Dim t As Long
		Dim i As Long
		Dim w As String
		Dim msgdata As MSG
		
		
		Call SetForegroundWindow(Me.hWnd)
		If Me.p.x < 0 Or Me.p.y < 0 Then Call GetCursorPos(Me.p)
		Call NEMDisableWaitCursor
		t = TrackPopupMenu(Me.hMenu, 256 + Me.anim, Me.r.x1, Me.r.y1, 0, Me.hWnd, Me.r)
		Call NEMEnableWaitCursor
		Me.selected = t
		l = GetMenuString(Me.hMenu, t, menuS, 0, 0) + 1
		Call GetMenuString(Me.hMenu, t, menuS, 1, 0)
'		Call GetMessage(Me.hWnd, 0, 0, 0)
		Call GetMessage(msgdata, Me.hWnd, 0, 0)
		
				For i = 1 To l - 1
			w = Mid(menuS, i, 1)
			showAsAction = showAsAction + w
		Next
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.showAsAction: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.showAsAction: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function hiliteItem
		Description: Comments for Function
	%END REM
	Public Function hiliteItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		If Me.hWnd = 0 Then GoTo fn
		
		Call HiliteMenuItem(Me.hWnd, Me.hMenu, pos - 1, 1152)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.hiliteItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.hiliteItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function unhiliteItem
		Description: Comments for Function
	%END REM
	Public Function unhiliteItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		If Me.hWnd = 0 Then GoTo fn
		
		Call HiliteMenuItem(Me.hWnd, Me.hMenu, pos - 1, 1024)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.unhiliteItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.unhiliteItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function setDefaultItem
		Description: Comments for Function
	%END REM
	Public Function setDefaultItem(pos As Long) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call SetMenuDefaultItem(Me.hMenu, pos - 1, 1)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.setDefaultItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.setDefaultItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function clearDefaultItem
		Description: Comments for Function
	%END REM
	Public Function clearDefaultItem As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Call SetMenuDefaultItem(Me.hMenu, - 1, 1)
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.clearDefaultItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.clearDefaultItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function showAsRightAction
		Description: Comments for Function
	%END REM
	Public Function showAsRightAction As String
		On Error GoTo eh
		
		showAsRightAction = ""
		If Me.hMenu = 0 Then GoTo fn
		If Me.hWnd = 0 Then GoTo fn
		
		Dim menuS As String*128
		Dim l As Long
		Dim t As Long
		Dim i As Long
		Dim w As String
		Dim msgdata As MSG
		
		
		Call SetForegroundWindow(Me.hWnd)
		If Me.p.x < 0 Or Me.p.y < 0 Then Call GetCursorPos(Me.p)
		Call NEMDisableWaitCursor
		t = TrackPopupMenu(Me.hMenu, 256 + Me.anim, Me.r.x2, Me.r.y2, 0, Me.hWnd, Me.r)
		Call NEMEnableWaitCursor
		Me.selected = t
		l = GetMenuString(Me.hMenu, t, menuS, 0, 0) + 1
		Call GetMenuString(Me.hMenu, t, menuS, 1, 0)
'		Call GetMessage(Me.hWnd, 0, 0, 0)
		Call GetMessage(msgdata, Me.hWnd, 0, 0)

		For i = 1 To l - 1
			w = Mid(menuS, i, 1)
			showAsRightAction = showAsRightAction + w
		Next
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.showAsAction: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.showAsAction: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function getSelectedPosition
		Description: Comments for Function
	%END REM
	Public Function getSelectedPosition As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Dim arr() As Integer
		ReDim arr(0) As Integer
		
		Call Me.getSelectedPos(Me.hMenu, arr)
		getSelectedPosition = arr()
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedPosition: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedPosition: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function getSelectedPos
		Description: Comments for Function
	%END REM
	Private Function getSelectedPos(hMenuLoc As Long, arr() As Integer) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		getSelectedPos = False
		
		Dim i As Integer
		Dim hMenu1 As Long
		Dim ID As Long
		
		For i = 0 To GetMenuItemCount(hMenuLoc)
			ID = GetMenuItemID(hMenuLoc, i)
			If ID = -1 Then
				hMenu1 = GetSubMenu(hMenuLoc, i)
				If hMenu1 <> 0 Then
					arr(UBound(arr)) = i + 1
					ReDim Preserve arr(UBound(arr) + 1)
					arr(UBound(arr)) = 0
					If Me.getSelectedPos(hMenu1, arr) = True Then
						getSelectedPos = True
						GoTo fn
					Else
						ReDim Preserve arr(UBound(arr) - 1)
						arr(UBound(arr)) = 0
					End If
				End If
			Else
				If ID = Me.selected Then
					arr(UBound(arr)) = i + 1
					getSelectedPos = True
					GoTo fn
				End If
			End If
		Next
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedPos: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedPos: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function getSelectedItem
		Description: Comments for Function
	%END REM
	Public Function getSelectedItems As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Dim arr() As String
		ReDim arr(0) As String
		
		Call Me.getSelectedItem(Me.hMenu, arr)
		getSelectedItems = arr()
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedItems: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedItems: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function getSelectedItem
		Description: Comments for Function
	%END REM
	Private Function getSelectedItem(hMenuLoc As Long, arr() As String) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		getSelectedItem = False
		
		Dim i As Integer
		Dim hMenu1 As Long
		Dim l As Long
		Dim t As String
		Dim ID As Long
		Dim menuS As String*128
		Dim txt As String
		Dim x As Long
		
		For i = 0 To GetMenuItemCount(hMenuLoc)
			ID = GetMenuItemID(hMenuLoc, i)
			If ID = -1 Then
				hMenu1 = GetSubMenu(hMenuLoc, i)
				If hMenu1 <> 0 Then
					l = GetMenuString(hMenuLoc, i, menuS, 0, 1024) + 1
					Call GetMenuString(hMenuLoc, i, menuS, l, 1024)
					txt = ""
					For x = 1 To l - 1
						t = Mid(menuS, x, 1)
						txt = txt + t
					Next
					ReDim Preserve arr(UBound(arr) + 1)
					arr(UBound(arr)) = txt
					If Me.getSelectedItem(hMenu1, Arr) = True Then
						getSelectedItem = True
						GoTo fn
					Else
						ReDim Preserve arr(UBound(arr) - 1)
					End If
				End If
			Else
				If ID = Me.selected Then
					l = GetMenuString(hMenuLoc, i, menuS, 0, 1024) + 1
					Call GetMenuString(hMenuLoc, i, menuS, l, 1024)
					txt = ""
					For x = 1 To l - 1
						t = Mid(menuS, x, 1)
						txt = txt + t
					Next
					ReDim Preserve arr(UBound(arr) + 1)
					arr(UBound(arr)) = txt
					getSelectedItem = True
					GoTo fn
				End If
			End If
		Next
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedItem: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getSelectedItem: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Property Get Animation
		Description: Comments for Property Get
	%END REM
	Property Get Animation As Variant
		If Me.anim = 0 Then Animation = True Else Animation = False
	End Property
	
	%REM
		Property Set Animation
		Description: Comments for Property Set
	%END REM
	Property Set Animation As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		Dim v As Long
		Dim v1 As Long
		Dim v2 As Long
		v = GetVersion() And &H00FF
		v1 = (v And &HF0)/256
		v2 = v And &HF0
		If v1 = 0 And (v2 = 4 Or v2 = 3) Then
			Me.anim = 0
		Else
			If Animation = True Then Me.anim = 0 Else Me.anim = 16384
		End If
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.Set Animation: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.Set Animation: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Property
	
	%REM
		Sub Delete
		Description: Comments for Sub
	%END REM
	Public Sub Delete
		On Error GoTo eh
		
		Call NEMDisableWaitCursor
		
		If Me.hMenu <> 0 Then DestroyMenu(Me.hMenu)
		Me.menuID = Me.menuID + 1
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.Delete: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.Delete: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Sub
	
	%REM
		Function getSubMenuArray
		Description: Comments for Function
	%END REM
	Public Function getSubMenuArray As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
	'	getSubMenuArray = Me.sMenuArr.getArray()
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getSubMenuArray: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getSubMenuArray: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function getParentMenuArray
		Description: Comments for Function
	%END REM
	Public Function getParentMenuArray As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
'		getParentMenuArray = Me.pMenuArr.getArray()
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.getParentMenuArray: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.getParentMenuArray: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function addParentMenu
		Description: Comments for Function
	%END REM
	Public Function addParentMenu(menu As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		
		addParentMenu = False
		Call Me.pMenuArr.appendElement(menu)
		addParentMenu = True
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.addParentMenu: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.addParentMenu: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
	
	%REM
		Function removeParentMenu
		Description: Comments for Function
	%END REM
	Public Function removeParentMenu(menu As Variant) As Variant
		On Error GoTo eh
		
		If Me.hMenu = 0 Then GoTo fn
		If Not Me.pMenuArr.IsInitialized() Then GoTo fn
		
		Dim i As Integer
		
		removeParentMenu = False
		Call Me.pMenuArr.reInitialize()
		removeParentMenu = True
		
		GoTo fn
eh:
		If GetLastError() = "" Then
			errS = Chr(10) & libName & " --> PopupMenu.removeParentMenu: " & Err & ", line " & Erl & Chr(10) & GetLastError()
		Else
			errS = Chr(10) & libName & " --> PopupMenu.removeParentMenu: " & Err & ", line " & Erl & Chr(10) & Error$
		End If
		Error Err, errS
fn:
	End Function
End Class
'++LotusScript Development Environment:2:2:Initialize:1:10
Sub Initialize
	Dim fName As String, errString As String
	On Error GoTo errH
	
	fName = libName & "--> Initialize"
	
	Set e = New ErrorH
'	Set s = New System
'	Call s.Initialize()
	GoTo fn
errH:
	errString = fName & Chr(10) & "стр." & Erl & ", " & Error$
	Call e.Initialize(Err, errString)
	Call e.Log
	Resume fn
fn:
End Sub
























